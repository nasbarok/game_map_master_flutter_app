import 'dart:async';
import 'dart:math';
import 'package:flutter/services.dart';
import 'package:airsoft_game_map/models/scenario/bomb_operation/bomb_site.dart';
import 'package:airsoft_game_map/models/scenario/bomb_operation/bomb_operation_scenario.dart';
import 'package:airsoft_game_map/services/scenario/bomb_operation/bomb_operation_service.dart';
import 'package:airsoft_game_map/utils/logger.dart';

/// Service de d√©tection automatique de proximit√© avec feedback sonore
class BombProximityDetectionService {
  final BombOperationService _bombOperationService;
  final BombOperationScenario _bombOperationScenario;
  final int _gameSessionId;
  final int _userId;
  
  // √âtat de d√©tection
  Timer? _detectionTimer;
  BombSite? _currentNearSite;
  bool _isInActiveZone = false;
  
  // Callbacks pour les √©v√©nements
  Function(BombSite site)? onEnterBombZone;
  Function(BombSite site)? onExitBombZone;
  Function(BombSite site, bool canArm, bool canDisarm)? onZoneStatusChanged;
  
  // Position actuelle
  double _currentLatitude = 0.0;
  double _currentLongitude = 0.0;
  
  // √âtats des sites (pour savoir si arm√© ou non)
  final Map<int, BombSiteState> _siteStates = {};

  BombProximityDetectionService({
    required BombOperationService bombOperationService,
    required BombOperationScenario bombOperationScenario,
    required int gameSessionId,
    required int userId,
  }) : _bombOperationService = bombOperationService,
       _bombOperationScenario = bombOperationScenario,
       _gameSessionId = gameSessionId,
       _userId = userId;

  /// D√©marre la d√©tection automatique de proximit√©
  void startDetection() {
    stopDetection(); // Arr√™ter toute d√©tection existante
    
    _detectionTimer = Timer.periodic(const Duration(seconds: 2), (timer) {
      _checkProximity();
    });
    
    logger.d('üîç [BombProximityDetection] D√©tection d√©marr√©e');
  }

  /// Arr√™te la d√©tection de proximit√©
  void stopDetection() {
    _detectionTimer?.cancel();
    _detectionTimer = null;
    
    // Si on √©tait dans une zone, d√©clencher la sortie
    if (_isInActiveZone && _currentNearSite != null) {
      _handleExitZone(_currentNearSite!);
    }
    
    logger.d('üîç [BombProximityDetection] D√©tection arr√™t√©e');
  }

  /// Met √† jour la position actuelle
  void updatePosition(double latitude, double longitude) {
    _currentLatitude = latitude;
    _currentLongitude = longitude;
  }

  /// Met √† jour l'√©tat d'un site de bombe
  void updateSiteState(int siteId, BombSiteState state) {
    _siteStates[siteId] = state;
    
    // Si c'est le site actuel, v√©rifier les actions possibles
    if (_currentNearSite?.id == siteId && _isInActiveZone) {
      _checkAvailableActions(_currentNearSite!);
    }
  }

  /// V√©rifie la proximit√© avec les sites de bombe
  Future<void> _checkProximity() async {
    try {
      final nearSite = await _bombOperationService.checkPlayerInActiveBombSite(gameSessionId: _gameSessionId, latitude: _currentLatitude, longitude: _currentLongitude);

      // V√©rifier si on a chang√© de zone
      if (nearSite?.id != _currentNearSite?.id) {
        // Sortie de l'ancienne zone
        if (_isInActiveZone && _currentNearSite != null) {
          _handleExitZone(_currentNearSite!);
        }
        
        // Entr√©e dans une nouvelle zone
        if (nearSite != null) {
          _handleEnterZone(nearSite);
        }
      }
      
    } catch (e) {
      logger.d('‚ùå [BombProximityDetection] Erreur lors de la v√©rification: $e');
    }
  }

  /// G√®re l'entr√©e dans une zone de bombe
  void _handleEnterZone(BombSite site) {
    _currentNearSite = site;
    _isInActiveZone = true;
    
    // Bip d'entr√©e dans la zone
    _playEnterZoneSound();
    
    // V√©rifier les actions possibles
    _checkAvailableActions(site);
    
    // Notifier l'entr√©e dans la zone
    onEnterBombZone?.call(site);
    
    logger.d('üéØ [BombProximityDetection] Entr√©e dans la zone: ${site.name}');
  }

  /// G√®re la sortie d'une zone de bombe
  void _handleExitZone(BombSite site) {
    _isInActiveZone = false;
    
    // Bip de sortie de zone
    _playExitZoneSound();
    
    // Notifier la sortie de zone
    onExitBombZone?.call(site);
    
    logger.d('üö∂ [BombProximityDetection] Sortie de la zone: ${site.name}');
    
    _currentNearSite = null;
  }

  /// V√©rifie les actions possibles sur le site actuel
  void _checkAvailableActions(BombSite site) {
    if (site.id == null) return;
    
    final siteState = _siteStates[site.id!] ?? BombSiteState.idle;
    
    // D√©terminer les actions possibles
    final canArm = siteState == BombSiteState.idle;
    final canDisarm = siteState == BombSiteState.armed;
    
    // Notifier les actions disponibles
    onZoneStatusChanged?.call(site, canArm, canDisarm);
    
    logger.d('‚öôÔ∏è [BombProximityDetection] Actions sur ${site.name}: arm=$canArm, disarm=$canDisarm');
  }

  /// Joue le son d'entr√©e dans une zone
  void _playEnterZoneSound() {
    try {
      // Bip court et aigu pour l'entr√©e
      HapticFeedback.lightImpact();
      // TODO: Ajouter un vrai son avec audioplayers
      logger.d('üîä [BombProximityDetection] Bip d\'entr√©e de zone');
    } catch (e) {
      logger.d('‚ùå [BombProximityDetection] Erreur son entr√©e: $e');
    }
  }

  /// Joue le son de sortie d'une zone
  void _playExitZoneSound() {
    try {
      // Bip plus grave pour la sortie
      HapticFeedback.mediumImpact();
      // TODO: Ajouter un vrai son avec audioplayers
      logger.d('üîä [BombProximityDetection] Bip de sortie de zone');
    } catch (e) {
      logger.d('‚ùå [BombProximityDetection] Erreur son sortie: $e');
    }
  }

  /// Joue un bip de progression pendant l'armement/d√©sarmement
  void playProgressSound() {
    try {
      HapticFeedback.selectionClick();
      // TODO: Ajouter un son de progression
      logger.d('üîä [BombProximityDetection] Bip de progression');
    } catch (e) {
      logger.d('‚ùå [BombProximityDetection] Erreur son progression: $e');
    }
  }

  /// Joue le bip final de confirmation
  void playCompletionSound(bool isSuccess) {
    try {
      if (isSuccess) {
        // Bip de succ√®s (plus long et satisfaisant)
        HapticFeedback.heavyImpact();
      } else {
        // Bip d'√©chec (vibration d'erreur)
        HapticFeedback.vibrate();
      }
      // TODO: Ajouter des sons diff√©rents pour succ√®s/√©chec
      logger.d('üîä [BombProximityDetection] Bip de ${isSuccess ? 'succ√®s' : '√©chec'}');
    } catch (e) {
      logger.d('‚ùå [BombProximityDetection] Erreur son completion: $e');
    }
  }

  /// V√©rifie si le joueur est actuellement dans une zone active
  bool get isInActiveZone => _isInActiveZone;

  /// Obtient le site actuel (si dans une zone)
  BombSite? get currentSite => _currentNearSite;

  /// V√©rifie si une action sp√©cifique est possible
  bool canPerformAction(BombActionType action) {
    if (!_isInActiveZone || _currentNearSite?.id == null) return false;
    
    final siteState = _siteStates[_currentNearSite!.id!] ?? BombSiteState.idle;
    
    switch (action) {
      case BombActionType.arm:
        return siteState == BombSiteState.idle;
      case BombActionType.disarm:
        return siteState == BombSiteState.armed;
    }
  }

  /// Nettoie les ressources
  void dispose() {
    stopDetection();
    logger.d('üßπ [BombProximityDetection] Service nettoy√©');
  }
}

/// √âtats possibles d'un site de bombe
enum BombSiteState {
  idle,      // Inactif, peut √™tre arm√©
  armed,     // Arm√©, peut √™tre d√©sarm√© ou va exploser
  disarmed,  // D√©sarm√©, inactif
  exploded   // Explos√©, inactif
}

/// Types d'actions possibles sur une bombe
enum BombActionType {
  arm,    // Armer la bombe
  disarm  // D√©sarmer la bombe
}

